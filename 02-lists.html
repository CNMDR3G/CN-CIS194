<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="stylesheet" href="./style.css" type="text/css">
  </head>
  <body>
<!--
Polymorphism and<br />Functional Programming Paradigms
-->
<h1 id="多态和函数式编程范式">多态和函数式编程范式</h1>
<p>CIS 194 Week 2<br />
28 January, 2015</p>
<!--
Additional Syntax
-->
<h2 id="其他语法">其他语法</h2>
<!--
The introduction in the first class meeting did not discuss local
variables. Here, we see a few examples of local variables in case these
constructs are useful for you in writing your homework solutions.
-->
<p>第一节课中没有介绍本地变量。现在，我们来看几个本地变量的例子，会对你们的作业有所帮助。</p>
<!--
**`let` expressions**
-->
<p><strong><code>let</code> 表达式</strong></p>
<!--
To define a local variable scoped over an expression, use `let`:
-->
<p>用 <code>let</code> 来定义表达式范围内的本地变量：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">strLength ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
strLength []     <span class="fu">=</span> <span class="dv">0</span>
strLength (_<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">let</span> len_rest <span class="fu">=</span> strLength xs <span class="kw">in</span>
                   len_rest <span class="fu">+</span> <span class="dv">1</span></code></pre></div>
<!--
In this case, the use of the local variable is a little silly (better
style would just be `1 + strLength xs`), but it demonstrates the use of
`let`. Don’t forget the `in` after you’ve defined your variable!
-->
<p>这个例子中的本地变量有点多余（较好的写法是 <code>1 + strLength xs</code>），但是给我们演示了 <code>let</code> 的用法。不要忘了变量定义之后的 <code>in</code>！</p>
<!--
**`where` clauses**
-->
<p><strong><code>where</code> 从句</strong></p>
<!--
To define a local variable scoped over multiple guarded branches, use
`where`:
-->
<p>用 <code>where</code> 来定义多个分支范围内的本地变量：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">frob ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
frob []  <span class="fu">=</span> <span class="ch">&#39;a&#39;</span>   <span class="co">-- len is NOT in scope here</span>
frob str
  <span class="fu">|</span> len <span class="fu">&gt;</span> <span class="dv">5</span>   <span class="fu">=</span> <span class="ch">&#39;x&#39;</span>
  <span class="fu">|</span> len <span class="fu">&lt;</span> <span class="dv">3</span>   <span class="fu">=</span> <span class="ch">&#39;y&#39;</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="ch">&#39;z&#39;</span>
  <span class="kw">where</span>
    len <span class="fu">=</span> strLength str</code></pre></div>
<!--
Note that the `len` variable can be used in any of the alternatives
immediately above the `where` clause, but not in the separate top-level
pattern `frob [] = 'a'`. In idiomatic Haskell code, `where` is somewhat
more common than `let`, because using `where` allows the programmer to
get right to the point in defining what a function does, instead of
setting up lots of local variables first.
-->
<p>注意 <code>len</code> 变量可以在 <code>where</code> 上方的各个选择分支内使用，但是不能在另一个顶层定义 <code>frob [] = 'a'</code> 中使用。比起 <code>let</code>，Haskell 中更习惯使用 <code>where</code>， 因为它可以让程序员首先关注函数本身做了什么，而不是先看到一堆本地变量的定义。</p>
<!--
**Haskell Layout**
-->
<p><strong>Haskell 程序的布局</strong></p>
<!--
Haskell is a *whitespace-sensitive* language. This is in stark contrast
to most other languages, where whitespace serves only to separate
identifiers. (Haskell shares this trait with Python, which is also
whitespace-sensitive.) Haskell uses indentation level to tell where
certain regions of code end, and where new statements appear. The basic
idea is that, when a so-called *layout herald* appears, GHC looks at the
next thing it sees and remembers its indentation level. A later line
that begins at the exact same indentation level is considered another
member of the group, and a later line that begins at a lesser (more to
the left) indentation level is not part of the group.
-->
<p>Haskell 是 <em>对空白字符敏感</em> 的语言，这和其他大多数仅把空白字符用来分割标示符的语言形成鲜明对比。 （Haskell 这点和 Python 相似。）Haskell 中缩进层次指示了代码块结束和新语句开始的位置。 基本上来说，当一个所谓的 <em>布局暗示</em> 出现的时候，GHC 看下一个位置并记住其缩进层次。 如果下一行缩进相同则被认为是同一组，如果下一行缩进更少则不认为是同一组。</p>
<!--
The layout heralds are `where`, `let`, `do`, `of`, and `case`. Because
Haskell modules begin with `module Name where`, that means that the
layout rule is in effect over the declarations in the file. This means
that the following is no good:
-->
<p>缩进暗示包括 <code>where</code>，<code>let</code>，<code>do</code>，<code>of</code> 和 <code>case</code>。 因为 Haskell 模块总是以 <code>module Name where</code>，开头， 表明布局规则对整个文件里的定义都起效。所以下面这样的定义有误：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">x ::</span> <span class="dt">Int</span>
x <span class="fu">=</span>
<span class="dv">5</span></code></pre></div>
<!--
The problem is that the `5` is at the same indentation level (zero) as
other top-level declarations, and so GHC considers it to be a new
declaration instead of part of the definition of `x`.
-->
<p>问题出在 <code>5</code> 和其他顶层定义缩进相同（零缩进），所以 GHC 认为这是一个新的定义而不是 <code>x</code> 的一部分。</p>
<!--
The layout rule is often a source of confusion for newcomers to Haskell.
But, if you get stuck, return to this decription (or, any of the many
online) and re-read — often, if you think carefully enough about it,
you’ll see what’s going on.
-->
<p>布局规则常常给 Haskell 新手带来困扰。如果你后面遇到麻烦，回来重新看这里（或者其他网络资料）—— 经常，多仔细想一想你就明白是怎么一回事了。</p>
<!--
When calculating indentation level, tabs in code (you don’t have any of
these, do you?!?) are considered with tab stops 8 characters apart,
regardless of what your editor might show you. This potential confusion
is why tabs are a terrible, terrible idea in Haskell code.
-->
<p>在计算缩进层次的时候，代码中的 tab （你没写对吧？！？）被认为是 8 个字符的长度， 而不一定是你的编辑器显示给你的长度。这种潜在的混乱使得 tab 在 Haskell 缩进中被认为是很不好的用法。</p>
<!--
**Accumulators**
-->
<p><strong>累加器</strong></p>
<!--
Haskell’s one way to repeat a computation is recursion. Recursion is a
natural way to express the solutions to many problems. However,
sometimes a problem’s structure doesn’t exactly match Haskell’s
structure. For example, say we have a list of numbers, that is, an
`[Int]`. We wish to sum the elements in the list, but only until the sum
is greater than 20. After that, the rest of the numbers should be
ignored. Because recursion over a list builds up the result from the end
backward, a naive recursion will not work for us. What we need is to
keep track of the running sum as we go deeper into the list. This
running sum is called an *accumulator*.
-->
<p>Haskell 中重复给定计算的方法之一是递归。递归是解决很多问题的自然的解法。 但是有时候问题的结构并不完全符合 Haskell 的结构。比如我们有一组数字的列表，<code>[Int]</code>。 我们想累加列表中数字的和，但是超过 20 就停止，忽略之后的数字。 因为列表上的递归是从后向前计算结果的，所以通常的递归并不符合我们的要求。 随着列表的深入，我们需要即时跟踪当前的和，这个和就叫做 <code>累加器</code>。</p>
<!--
Here is the code that solves the stated problem:
-->
<p>这是解决上面问题的代码：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">sumTo20 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
sumTo20 nums <span class="fu">=</span> go <span class="dv">0</span> nums   <span class="co">-- the acc. starts at 0</span>
  <span class="kw">where</span><span class="ot"> go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
        go acc [] <span class="fu">=</span> acc   <span class="co">-- empty list: return the accumulated sum</span>
        go acc (x<span class="fu">:</span>xs)
         <span class="fu">|</span> acc <span class="fu">&gt;=</span> <span class="dv">20</span> <span class="fu">=</span> acc
         <span class="fu">|</span> otherwise <span class="fu">=</span> go (acc <span class="fu">+</span> x) xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">sumTo20 [<span class="dv">4</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">2</span>,<span class="dv">8</span>] <span class="fu">==</span> <span class="dv">23</span></code></pre></div>
<!--
*Parametric* polymorphism
-->
<h2 id="参数多态"><em>参数</em>多态</h2>
<!--
One important thing to note about polymorphic functions is that **the
caller gets to pick the types**. When you write a polymorphic function,
it must work for every possible input type. This – together with the
fact that Haskell has no way to directly make make decisions based on
what type something is – has some interesting implications.
-->
<p>多态函数的一个重要的特点是 <strong>调用者决定类型</strong>。 当你写一个多态函数时，它应该对所有可能的输入类型都工作。 这连同事实上 Haskell 无法只根据某表达式类型直接做决定的特点，产生了一些有趣的意味（？）。</p>
<!--
For starters, the following is very bogus:
-->
<p>对初学者来说，下面的代码很<em>假</em>:</p>
<pre><code>bogus :: [a] -&gt; Bool
bogus (&#39;X&#39;:_) = True
bogus _       = False</code></pre>
<!--
It’s bogus because the definition of `bogus` assumes that the input is a
`[Char]`. The function does not make sense for *any* value of the type
variable `a`. On the other hand, the following is just fine:
-->
<p><em>假</em>是因为 <code>bogus</code> 的定义实际上假定了输入是 <code>[Char]</code>。这个函数并不能对<em>任意</em>类型的 a 奏效。 与之相反，下面的代码没有问题：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">notEmpty ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
notEmpty (_<span class="fu">:</span>_) <span class="fu">=</span> <span class="dt">True</span>
notEmpty []    <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<!--
The `notEmpty` function does not care what `a` is. It will always just
make sense.
-->
<p><code>notEmpty</code> 函数并不关心 <code>a</code> 是什么，就能工作。</p>
<!--
This “not caring” is what the “parametric” in parametric polymorphism
means. All Haskell functions must be parametric in their type
parameters; the functions must not care or make decisions based on the
choices for these parameters. A function can’t do one thing when `a` is
`Int` and a different thing when `a` is `Bool`. Haskell simply provides
no facility for writing such an operation. This property of a langauge
is called *parametricity*.
-->
<p>这种“不关心”就是参数多态中“参数化（parametric）”的含义。 所有的 Haskell 函数实例对于它的类型都必须是参数化的；函数不能介意或者根据这些类型参数做选择（？）。 函数不能在 <code>a</code> 是 <code>Int</code> 时做一种事而在 <code>a</code> 是 <code>Bool</code> 时做另一种事。 Haskell 不提供这样的操作。这种语言特性叫做 <em>参态（parametricity）</em>。</p>
<!--
There are many deep and profound consequences of parametricity. One
consequence is something called *type erasure*. Because a running
Haskell program can never make decisions based on type information, all
the type information can be dropped during compilation. Despite how
important types are when writing Haskell code, they are completely
irrelevant when running Haskell code. This property gives Haskell a huge
speed boost when compared to other languages, such as Python, that need
to keep types around at runtime. (Type erasure is not the only thing
that makes Haskell faster, but Haskell is sometimes clocked at 20x
faster than Python.)
-->
<p>参态意味深远。其中之一常被叫做 <em>类型擦除</em>。 因为 Haskell 运行的时候不能再根据类型信息做决定，所以所有的类型信息在编译期间就可以被抛弃掉了。 不管类型对于 Haskell 代码来说多么重要，他们和运行中的程序都没有关系。 这个特性给 Haskell 带来了相比其他需要在运行时保留类型信息的语言（比如 Python）巨大的速度提升。 （类型擦除并不是唯一让 Haskell 更快的方法，但 Haskell 有时候能比 Python 快 20 倍。）</p>
<!--
Another consequence of parametricity is that it restricts what
polymorphic functions you can write. Look at this type signature:
-->
<p>参态的另一个影响是它限制了多态函数的实现。例如如下的类型签名：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">strange ::</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<!--
The `strange` function takes a value of some type `a` and produces a
value of another type `b`. But, crucially, it isn’t allowed to care what
`a` and `b` are! Thus, *there is no way to write `strange`*!
-->
<p><code>strange</code> 函数获得一个类型是 <code>a</code> 的东西产生另一个类型是 <code>b</code> 的东西。 但是关键是它不能关心 <code>a</code> 和 <code>b</code> 具体是什么。<em>所以根本没有办法写出这样的 <code>strange</code>！</em></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">strange <span class="fu">=</span> error <span class="st">&quot;impossible!&quot;</span></code></pre></div>
<!--
(The function `error`, defined in the `Prelude`, aborts your program
with a message.)
-->
<p>（<code>Prelude</code> 中定义的 <code>error</code> 函数可以终止整个程序并显示指定信息。）</p>
<!--
What about
-->
<p>再来看看</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">limited ::</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<!--
That function must produce an `a` when given an `a`. There is only one
`a` it can produce – the one it got! Thus, there is only one possible
definition for `limited`:
-->
<p>这个函数对于给定的 <code>a</code> 产生 <code>a</code>。只有唯一的 <code>a</code> 它能产生，就是它获得的那个！ 所以 <code>limited</code> 只可能有一种实现：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">limited x <span class="fu">=</span> x</code></pre></div>
<!--
In general, given the type of a function, it is possible to figure out
various properties of the function just by thinking about parametricity.
The function must have *some* way of producing the output type… but
where could values of that type come from? By answering this question,
you can learn a lot about a function.
-->
<p>总体来说，给定一个函数的类型，只根据参态就可以推断出该函数的很多特性。 函数可以有<em>多种</em>产生输出值的方式……但是给定类型的值从何而来？ 通过试图回答这个问题，可以获得对函数的一些了解。</p>
<!--
Total and partial functions
-->
<h2 id="total-函数和-partial-函数">Total 函数和 partial 函数</h2>
<!--
Consider this polymorphic type:
-->
<p>考虑下面的多态类型：</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[a] <span class="ot">-&gt;</span> a</code></pre></div>
<!--
What functions could have such a type? The type says that given a list
of things of type `a`, the function must produce some value of type `a`.
For example, the Prelude function `head` has this type.
-->
<p>什么样的函数有这样的类型？这个类型说明了给定一个 <code>a</code> 类型的列表，函数必须产生一个类型为 <code>a</code> 的值。 例如 Prelude 里的函数 <code>head</code> 既是此类型。</p>
<!--
It crashes! There’s nothing else it possibly could do, since it must
work for *all* types. There’s no way to make up an element of an
arbitrary type out of thin air.
-->
<p>糟糕！好像除此之外没有别的选择了，因为这个函数必须能对<em>所有</em>类型工作。 没有办法凭空造出来一个任意类型的值。</p>
<!--
`head` is what is known as a *partial function*: there are certain
inputs for which `head` will crash. Functions which have certain inputs
that will make them recurse infinitely are also called partial.
Functions which are well-defined on all possible inputs are known as
*total functions*.
-->
<p><code>head</code> 就是俗称的 <em>partial 函数</em>：对于某些输入不能工作。 函数在某些输入上无限递归也叫做 partial。 函数在所有可能的输入上都有良好的定义叫做 <em>total 函数</em>。</p>
<!--
It is good Haskell practice to avoid partial functions as much as
possible. Actually, avoiding partial functions is good practice in *any*
programming language—but in most of them it’s ridiculously annoying.
Haskell tends to make it quite easy and sensible.
-->
<p>好的 Haskell 实践当然是尽量避免 partial 函数。 避免 partial 函数也是 <em>任何</em> 编程语言中的良好实践 —— 但是在大多数语言中极为麻烦。 而在 Haskell 中往往简单又合理。</p>
<!--
**`head` is a mistake!** It should not be in the `Prelude`. Other
partial `Prelude` functions you should almost never use include `tail`,
`init`, `last`, and `(!!)`. From this point on, using one of these
functions on a homework assignment will lose style points!
-->
<p><strong><code>head</code> 是一个错误！</strong> 它不应该存在 <code>Prelude</code> 中。 其他你应该尽力避免的 Prelude 中的 partial 函数包括 <code>tail</code>、<code>init</code>、<code>last</code> 和 <code>(!!)</code>。 从现在开始在作业中使用其中任意一个函数都会丢掉样式分！</p>
<!--
What to do instead?
-->
<p>那应该怎么做？</p>
<!--
**Replacing partial functions**
-->
<p><strong>替换 partial 函数</strong></p>
<!--
Often partial functions like `head`, `tail`, and so on can be replaced
by pattern-matching. Consider the following two definitions:
-->
<p>像 <code>head</code>、<code>tail</code> 等等 partial 函数常常可以被模式匹配取代。比如下面两个定义：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">doStuff1 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
doStuff1 []  <span class="fu">=</span> <span class="dv">0</span>
doStuff1 [_] <span class="fu">=</span> <span class="dv">0</span>
doStuff1 xs  <span class="fu">=</span> head xs <span class="fu">+</span> (head (tail xs))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">doStuff2 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
doStuff2 []        <span class="fu">=</span> <span class="dv">0</span>
doStuff2 [_]       <span class="fu">=</span> <span class="dv">0</span>
doStuff2 (x1<span class="fu">:</span>x2<span class="fu">:</span>_) <span class="fu">=</span> x1 <span class="fu">+</span> x2</code></pre></div>
<!--
These functions compute exactly the same result, and they are both
total. But only the second one is *obviously* total, and it is much
easier to read anyway.
-->
<p>这两个函数做了同样的事，而且也都是 total 的。但是只有第二个 <em>显然</em> 是 total 的，而且更易读。</p>
<!--
Recursion patterns
-->
<h2 id="递归模式">递归模式</h2>
<!--
What sorts of things might we want to do with an `[a]`? Here are a few
common possibilities:

-   Perform some operation on every element of the list

-   Keep only some elements of the list, and throw others away, based on
    a test

-   “Summarize” the elements of the list somehow (find their sum,
    product, maximum…).

-   You can probably think of others!
-->
<p>对于 <code>[a]</code> 我们可能会做什么？有几种可能：</p>
<ul>
<li><p>对列表中的每一个元素做某种操作</p></li>
<li><p>基于某种测试，只保留一些元素，丢掉其他的</p></li>
<li><p>对所有元素做“总结”（比如求和、求积、最大值）</p></li>
<li><p>你能想到的其他的！</p></li>
</ul>
<!--
**Map**
-->
<p><strong>映射（Map）</strong></p>
<!--
Let’s think about the first one (“perform some operation on every
element of the list”). For example, we could add one to every element in
a list:
-->
<p>让我们来考虑第一种情况（对列表中的每一个元素做某种操作）。 比如我们可以对列表中的每一个元素加一：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">addOneToAll ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
addOneToAll []     <span class="fu">=</span> []
addOneToAll (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span> <span class="fu">:</span> addOneToAll xs</code></pre></div>
<!--
Or we could ensure that every element in a list is nonnegative by taking
the absolute value:
-->
<p>或者对每一个取绝对值得到一个非负的列表：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">absAll ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
absAll []     <span class="fu">=</span> []
absAll (x<span class="fu">:</span>xs) <span class="fu">=</span> abs x <span class="fu">:</span> absAll xs</code></pre></div>
<!--
Or we could square every element:
-->
<p>或者对每一个平方：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">squareAll ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
squareAll []     <span class="fu">=</span> []
squareAll (x<span class="fu">:</span>xs) <span class="fu">=</span> x<span class="fu">^</span><span class="dv">2</span> <span class="fu">:</span> squareAll xs</code></pre></div>
<!--
At this point, big flashing red lights and warning bells should be going
off in your head. These three functions look way too similar. There
ought to be some way to abstract out the commonality so we don’t have to
repeat ourselves!
-->
<p>现在，你脑中应该有红灯闪烁警报作响了，这几个函数这么相像， 应该有什么办法把这种共性抽象出来，省去我们的重复工作了。</p>
<!--
There is indeed a way—can you figure it out? Which parts are the same in
all three examples and which parts change?
-->
<p>确实有这么一种办法，你有没有看出来？这三个例子里哪些部分是相同的，哪些部分变化了？</p>
<!--
The thing that changes, of course, is the operation we want to perform
on each element of the list. We can specify this operation as a
*function* of type `a -> a`. Here is where we begin to see how
incredibly useful it is to be able to pass functions as inputs to other
functions!
-->
<p>变化的，当然，是我们相对每个元素做的操作。我们可以把这个操作特化为一个类型为 <code>a -&gt; a</code> 的函数。 现在我们看到了把函数当做函数的输入的大用途！</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map _ []     <span class="fu">=</span> []
map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</code></pre></div>
<!--
We can now use `mapIntList` to implement `addOneToAll`, `absAll`, and
`squareAll`:
-->
<p>我们现在可以用 <code>map</code> 来实现 <code>addOneToAll</code>、<code>absAll</code> 和 <code>squareAll</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">exampleList <span class="fu">=</span> [<span class="fu">-</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">6</span>]</code></pre></div>
<pre><code>map (+1) exampleList
map abs  exampleList
map (^2) exampleList</code></pre>
<!--
**Filter**
-->
<p><strong>过滤（Filter）</strong></p>
<!--
Another common pattern is when we want to keep only some elements of a
list, and throw others away, based on a test. For example, we might want
to keep only the positive numbers:
-->
<p>另一种常见的模式是我们只想根据某种测试保留列表中的部分元素，扔掉其他的。 比如我们只想保留所有的正数：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">keepOnlyPositive ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
keepOnlyPositive [] <span class="fu">=</span> []
keepOnlyPositive (x<span class="fu">:</span>xs) 
  <span class="fu">|</span> x <span class="fu">&gt;</span> <span class="dv">0</span>     <span class="fu">=</span> x <span class="fu">:</span> keepOnlyPositive xs
  <span class="fu">|</span> otherwise <span class="fu">=</span> keepOnlyPositive xs</code></pre></div>
<!--
Or only the even ones:
-->
<p>或者只保留所有的偶数：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">keepOnlyEven ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
keepOnlyEven [] <span class="fu">=</span> []
keepOnlyEven (x<span class="fu">:</span>xs)
  <span class="fu">|</span> even x    <span class="fu">=</span> x <span class="fu">:</span> keepOnlyEven xs
  <span class="fu">|</span> otherwise <span class="fu">=</span> keepOnlyEven xs</code></pre></div>
<!--
How can we generalize this pattern? What stays the same, and what do we
need to abstract out?
-->
<p>如何抽象这种模式？哪部分是不变的，需要抽象出来？</p>
<!--
The thing to abstract out is the *test* (or *predicate*) used to
determine which values to keep. A predicate is a function of type
`a -> Bool` which returns `True` for those elements which should be
kept, and `False` for those which should be discarded. So we can write
`filterIntList` as follows:
-->
<p>需要抽象出来的是用来决定哪些值该保留下来的 <em>测试</em> （或者说 <em>断言</em>）这部分。 断言是一个类型为 <code>a -&gt; Bool</code> 的函数，对应当保留的值返回 <code>True</code>，应当忽略的值返回 <code>False</code>。 所以我们可以改写 <code>filterIntList</code> 如下：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">filter<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
filte _ [] <span class="fu">=</span> []
filter p (x<span class="fu">:</span>xs)
  <span class="fu">|</span> p x       <span class="fu">=</span> x <span class="fu">:</span> filter p xs
  <span class="fu">|</span> otherwise <span class="fu">=</span> filter p xs</code></pre></div>
<!--
**Fold**
-->
<p><strong>折叠（Fold）</strong></p>
<!--
We have one more recursion pattern on lists to talk about: folds. Here
are a few functions on lists that follow a similar pattern: all of them
somehow “combine” the elements of the list into a final answer.
-->
<p>还有一个列表上的递归模式我们还没有说到：折叠。下面是几个模式相似的列表上的函数： 所有都试图 “结合” 所有列表中的元素来得到一个值。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">sum&#39; ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
sum&#39; []     <span class="fu">=</span> <span class="dv">0</span>
sum&#39; (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sum&#39; xs

<span class="ot">product&#39; ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
product&#39; [] <span class="fu">=</span> <span class="dv">1</span>
product&#39; (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">*</span> product&#39; xs

<span class="ot">length&#39; ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>
length&#39; []     <span class="fu">=</span> <span class="dv">0</span>
length&#39; (_<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> length&#39; xs</code></pre></div>
<!--
What do these three functions have in common, and what is different? As
usual, the idea will be to abstract out the parts that vary, aided by
the ability to define higher-order functions.
-->
<p>这几个函数有什么共同点，又有什么不同？像刚才一样，我们想用高阶函数来把变化的部分抽象出来。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fold ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b  <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
fold f z []     <span class="fu">=</span> z
fold f z (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (fold f z xs)</code></pre></div>
<!--
Notice how `fold` essentially replaces `[]` with `z` and `(:)` with `f`,
that is,
-->
<p>注意到 <code>fold</code> 中把 <code>z</code> 替换为 <code>[]</code>，把 <code>(:)</code> 替换为 <code>f</code>，即</p>
<pre><code>fold f z [a,b,c] == a `f` (b `f` (c `f` z))</code></pre>
<!--
(If you think about `fold` from this perspective, you may be able to
figure out how to generalize `fold` to data types other than lists…)
-->
<p>从这个角度来看，你可能就知道如何推广 <code>fold</code> 到其他列表之外的数据结构上了。</p>
<!--
Now let’s rewrite `sum'`, `product'`, and `length'` in terms of `fold`:
-->
<p>下面，我们来用 <code>fold</code> 重写一下 <code>sum'</code>、<code>product'</code> 和 <code>length'</code>：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">sum&#39;&#39;     <span class="fu">=</span> fold (<span class="fu">+</span>) <span class="dv">0</span>
product&#39;&#39; <span class="fu">=</span> fold (<span class="fu">*</span>) <span class="dv">1</span>
length&#39;&#39;  <span class="fu">=</span> fold addOne <span class="dv">0</span>
 <span class="kw">where</span> addOne _ s <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> s</code></pre></div>
<!--
Of course, `fold` is already provided in the standard Prelude, under the
name
[`foldr`](http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldr).
Here are some Prelude functions which are defined in terms of `foldr`:
-->
<p>当然，<code>fold</code> 已经在 <code>Prelude</code> 中了，叫做 <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldr"><code>foldr</code></a>。 下面是一些 <code>Prelude</code> 中用 <code>foldr</code> 定义了的函数：</p>
<ul>
<li><code>length</code> <code>::          [a] -&gt; Int</code></li>
<li><code>sum</code> <code>:: Num a =&gt; [a] -&gt; a</code></li>
<li><code>product</code> <code>:: Num a =&gt; [a] -&gt; a</code></li>
<li><code>and</code> <code>::          [Bool] -&gt; Bool</code></li>
<li><code>or</code> <code>::          [Bool] -&gt; Bool</code></li>
<li><code>any</code> <code>:: (a -&gt; Bool) -&gt; [a] -&gt; Bool</code></li>
<li><code>all</code> <code>:: (a -&gt; Bool) -&gt; [a] -&gt; Bool</code></li>
</ul>
<!--
There is also
[`foldl`](http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldl),
which folds “from the left”. That is,
-->
<p>还有一个 <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldl"><code>foldl</code></a>, 表示 “从左向右” 折叠，即</p>
<pre><code>foldr f z [a,b,c] == a `f` (b `f` (c `f` z))
foldl f z [a,b,c] == ((z `f` a) `f` b) `f` c</code></pre>
<!--
In general, however, you should use [`foldl'` from
`Data.List`](http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:foldl)
instead, which does the same thing as `foldl` but is more efficient.
-->
<p>但一般情况下，你应该用 <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:foldl"><code>Data.List</code> 中的 <code>foldl'</code></a> 代替 <code>foldl</code>。它们做的事是一样的，但前者更高效。</p>
<!--
Functional Programming
-->
<h2 id="函数式编程">函数式编程</h2>
<!--
We have seen now several cases of using a functional programming style.
Here, we will look at several functions using a very functional style to
help you get acclimated to this mode of programming.
-->
<p>我们已经见过不少函数式编程的例子了。 为了让你更加适应这种编程的方式，我们现在来看看几个非常具有函数式风格的函数。</p>
<!--
**Functional combinators**
-->
<p><strong>函数式组合子</strong></p>
<!--
First, we need a few more combinators to get us going:
-->
<p>首先，我们还需要几个组合子：</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
(<span class="fu">.</span>) f g x <span class="fu">=</span> f (g x)</code></pre></div>
<!--
The `(.)` operator, part of the Haskell Prelude, is just function
composition. Say we want to take every element of a list and add 1 and
then multiply by 4. Here is a good way to do it:
-->
<p>Prelude 中的 <code>(.)</code> 操作符既是函数的组合。 比如我们想要把列表中的每个元素加一然后乘以四，可以这样做：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">add1Mul4 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
add1Mul4 x <span class="fu">=</span> map ((<span class="fu">*</span><span class="dv">4</span>) <span class="fu">.</span> (<span class="fu">+</span><span class="dv">1</span>)) x</code></pre></div>
<!--
While we’re at it, we should also show the `($)` operator, which has a
trivial-looking definition:
-->
<p>同时我们也来看看 <code>($)</code> 操作符，它的定义很简单：</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">($) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
f <span class="fu">$</span> x <span class="fu">=</span> f x</code></pre></div>
<!--
Why have such a thing? Because `($)` is parsed as an operator, and this
is useful for avoiding parentheses. For example, if we wish to negate
the number of even numbers in a list, we could say
-->
<p>为什么需要这个函数？因为 <code>($)</code> 是一个操作符，可以避免许多括号的使用。 比如，如果我们想对列表中的偶数的个数取负，可以这样写</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">negateNumEvens1 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
negateNumEvens1 x <span class="fu">=</span> negate (length (filter even x))</code></pre></div>
<!--
or
-->
<p>或者这样</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">negateNumEvens2 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
negateNumEvens2 x <span class="fu">=</span> negate <span class="fu">$</span> length <span class="fu">$</span> filter even x</code></pre></div>
<!--
No more parentheses!
-->
<p>少了很多括号呢！</p>
<p><strong>Lambda</strong></p>
<!--
It is sometimes necessary to create an anonymous function, or *lambda
expression*. This is best explained by example. Say we want to duplicate
every string in a list:
-->
<p>有时候我们需要创建匿名的函数，即 <em>lambda 表达式</em>。用例子来说明，比如我们重复列表中的所有字符串：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">duplicate1 ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>]
duplicate1 <span class="fu">=</span> map dup
  <span class="kw">where</span> dup x <span class="fu">=</span> x <span class="fu">++</span> x</code></pre></div>
<!--
It’s a tiny bit silly to name `dup`. Instead, we can make an anonymous
function:
-->
<p>单独给 <code>dup</code> 起个名字有点多余。其实，我们可以写成匿名函数：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">duplicate2 ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>]
duplicate2 <span class="fu">=</span> map (\x <span class="ot">-&gt;</span> x <span class="fu">++</span> x)</code></pre></div>
<!--
The backslash binds the variables after it in the expression that
follows the `->`. For anything but the shortest examples, it’s better to
use a named helper function, though.
-->
<p>反斜线后面的变量名被绑定在 <code>-&gt;</code> 后面的表达式里。不过，长一些的函数还是起个名字最好。</p>
<!--
Currying and Partial Application
-->
<h2 id="柯里化currying和部分应用">柯里化（currying）和部分应用</h2>
<!--
Remember how the types of multi-argument functions look weird, like they
have “extra” arrows in them? For example, consider the function
-->
<p>还记得么，多参数函数的类型奇奇怪怪，中间有很多 “多余的” 箭头？比如这个函数</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f x y <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>x <span class="fu">+</span> y</code></pre></div>
<!--
I promise that there is a beautiful, deep reason for this, and now it’s
finally time to reveal it: *all functions in Haskell take only one
argument*. Say what?! But doesn’t the function `f` shown above take two
arguments? No, actually, it doesn’t: it takes one argument (an `Int`)
and *outputs a function* (of type `Int -> Int`); that function takes one
argument and returns the final answer. In fact, we can equivalently
write `f`’s type like this:
-->
<p>我说过这其中是有优美而深刻的原因的，现在终于是时间揭晓了： <em>其实所有的 Haskell 中的函数只有一个参数</em>。 什么<!--鬼-->？！上面这个函数 <code>f</code> 不是就有两个参数吗？ 其实不是：它得到第一个参数（<code>Int</code>）然后返回了另一个函数（类型为 <code>Int -&gt; Int</code>）； 而这个函数得到另一个参数才返回最终的结果。 事实上我们可以把 <code>f</code> 的类型写成这样：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">f&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)
f&#39; x y <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>x <span class="fu">+</span> y</code></pre></div>
<!--
In particular, note that function arrows *associate to the right*, that
is, `W -> X -> Y -> Z` is equivalent to `W -> (X -> (Y -> Z))`. We can
always add or remove parentheses around the rightmost top-level arrow in
a type.
-->
<p>需要指出的是，类型中的箭头是 <em>向右结合</em> 的，<code>W -&gt; X -&gt; Y -&gt; Z</code> 等价于 <code>W -&gt; (X -&gt; (Y -&gt; Z))</code>。 类型中最右顶层的的括号既可以加上也可以去掉。</p>
<!--
Function application, in turn, is *left*-associative. That is, `f 3 2`
is really shorthand for `(f 3) 2`. This makes sense given what we said
previously about `f` actually taking one argument and returning a
function: we apply `f` to an argument `3`, which returns a function of
type `Int -> Int`, namely, a function which takes an `Int` and adds 6 to
it. We then apply that function to the argument `2` by writing
`(f 3) 2`, which gives us an `Int`. Since function application
associates to the left, however, we can abbreviate `(f 3) 2` as `f 3 2`,
giving us a nice notation for `f` as a “multi-argument” function.
-->
<p>反过来，函数应用是 <em>左</em> 结合的。<code>f 3 2</code> 其实是 <code>(f 3) 2</code> 的简写。 这么说我们之前说的 <code>f</code> 其实只需要一个参数然后返回另一个函数就合理了： 我们先把 <code>f</code> 应用在参数 <code>3</code> 上，返回一个类型为 <code>Int -&gt; Int</code> 的函数，即一个对整数加六的函数。 然后把这个函数应用在参数 <code>2</code> 上，写作 <code>(f 3) 2</code>，最后得到一个整数。 因为函数应用是左结合的，所以我们可以把 <code>(f 3) 2</code> 缩写为 <code>f 3 2</code>， 看起来 <code>f</code> 就像一个“多参数”的函数一样。</p>
<!--
The “multi-argument” lambda abstraction
-->
<p>“多参数”的 lambda</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">\x y z <span class="ot">-&gt;</span> <span class="fu">...</span></code></pre></div>
<!--
is really just syntax sugar for
-->
<p>其实只是</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">\x <span class="ot">-&gt;</span> (\y <span class="ot">-&gt;</span> (\z <span class="ot">-&gt;</span> <span class="fu">...</span>))</code></pre></div>
<p>的语法糖。</p>
<!--
Likewise, the function definition
-->
<p>同样，下面的定义</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f x y z <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<!--
is syntax sugar for
-->
<p>也是</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">=</span> \x <span class="ot">-&gt;</span> (\y <span class="ot">-&gt;</span> (\z <span class="ot">-&gt;</span> <span class="fu">...</span>))<span class="fu">.</span></code></pre></div>
<p>的语法糖。</p>
<!--
This idea of representing multi-argument functions as one-argument
functions returning functions is known as *currying*, named for the
British mathematician and logician Haskell Curry. (His first name might
sound familiar; yes, it’s the same guy.) Curry lived from 1900-1982 and
spent much of his life at Penn State—but he also helped work on ENIAC at
UPenn. The idea of representing multi-argument functions as one-argument
functions returning functions was actually first discovered by Moses
Schönfinkel, so we probably ought to call it *schönfinkeling*. Curry
himself attributed the idea to Schönfinkel, but others had already
started calling it “currying” and it was too late.
-->
<p>把多参数函数表示为单参数并返回函数的函数既是 <em>柯里化（currying）</em>，以英国数学和逻辑学家 Haskell Curry 命名。 （他的姓我们应该很熟悉，对，就是他。）柯里生于 1900 年，逝于 1982 年，在宾州度过了他的大部分时光。 把多参数函数表示为单参数并返回函数的函数的想法其实首先是 Moses Schönfinkel 提出的， 所以可能更应该叫做 <em>schönfinkeling</em>。 柯里自己也指出这个想法来源于 schönfinkel，但是太晚了，别人已经开始称其为 “currying” 了。</p>
<!--
If we want to actually represent a function of two arguments we can use
a single argument which is a tuple. That is, the function
-->
<p>如果我们实在想表示一个有两个参数的函数，我们可以用一个元祖（tuple）来当参数。即</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">f&#39;&#39; ::</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>
f&#39;&#39; (x,y) <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>x <span class="fu">+</span> y</code></pre></div>
<!--
can also be thought of as taking “two arguments”, although in another
sense it really only takes one argument which happens to be a pair. In
order to convert between the two representations of a two-argument
function, the standard library defines functions called `curry` and
`uncurry`, defined like this (except with different names):
-->
<p>这个函数可以看做有“两个”参数，尽管它只是有“一对”参数。 标准库里的 <code>curry</code> 和 <code>uncurry</code> 两个函数提供了这两种表达方式之间的转换：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">schö<span class="ot">nfinkel ::</span> ((a,b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c
schönfinkel f x y <span class="fu">=</span> f (x,y)

unschö<span class="ot">nfinkel ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a,b) <span class="ot">-&gt;</span> c
unschönfinkel f (x,y) <span class="fu">=</span> f x y</code></pre></div>
<!--
`uncurry` in particular can be useful when you have a pair and want to
apply a function to it. For example:
-->
<p>当你有一对元祖，想把它应用在一个函数上时，<code>uncurry</code> 就特别有用了。比如：</p>
<pre><code>Prelude&gt; uncurry (+) (2,3)
5</code></pre>
<!--
**Partial application**
-->
<p><strong>部分应用</strong></p>
<!--
The fact that functions in Haskell are curried makes *partial
application* particularly easy. The idea of partial application is that
we can take a function of multiple arguments and apply it to just *some*
of its arguments, and get out a function of the remaining arguments. But
as we’ve just seen, in Haskell there *are no* functions of multiple
arguments! Every function can be “partially applied” to its first (and
only) argument, resulting in a function of the remaining arguments.
-->
<p>Haskell 的函数都已经柯里化了，这使得 <em>部分应用</em> 非常简单。 部分应用的意思是指，我们把一个多参数的函数只应用到<em>一部分</em>参数上，得到一个可以应用剩余参数的函数。 但是我们刚刚已经见过了，Haskell 中从来 <em>没有</em> 多参数的函数！ 每一个函数都可以（并只能）被“部分应用”在它的第一个参数上，得到一个一个可以应用剩余参数的函数。</p>
<!--
Note that Haskell doesn’t make it easy to partially apply to an argument
other than the first. The one exception is infix operators, which as
we’ve seen, can be partially applied to either of their two arguments
using an operator section. In practice this is not that big of a
restriction. There is an art to deciding the order of arguments to a
function to make partial applications of it as useful as possible: the
arguments should be ordered from “least to greatest variation”, that is,
arguments which will often be the same should be listed first, and
arguments which will often be different should come last.
-->
<p>注意在 Haskell 里部分应用除了第一个参数之外的参数就不容易了，除非使用中缀操作符。 我们已经见过，通过操作符域，中缀操作符可以被部分应用在它的两个参数任意一个上面。 所以在实际应用中这并不是什么限制了。 函数的参数的顺序是有讲究的，要使得部分应用越方便越好：参数的顺序应服从“最小变化到最可能变化”。 即，不大会变的参数放在前面，时常变化的参数放在后面。</p>
<!--
**Wholemeal programming**
-->
<p><strong>全麦编程</strong></p>
<!--
Let’s put some of the things we’ve just learned together in an example
that also shows the power of a “wholemeal” style of programming.
Consider the function `foobar`, defined as follows:
-->
<p>让我们来把刚学过的东西都放到一个例子里来，显示一下“全麦”风格的编程的威力。 比如如下定义的 <code>foobar</code> 函数：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">foobar ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
foobar []     <span class="fu">=</span> <span class="dv">0</span>
foobar (x<span class="fu">:</span>xs)
  <span class="fu">|</span> x <span class="fu">&gt;</span> <span class="dv">3</span>     <span class="fu">=</span> (<span class="dv">7</span><span class="fu">*</span>x <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> foobar xs
  <span class="fu">|</span> otherwise <span class="fu">=</span> foobar xs</code></pre></div>
<!--
This seems straightforward enough, but it is not good Haskell style. The
problem is that it is

-   doing too much at once; and
-   working at too low of a level.

Instead of thinking about what we want to do with each element, we can
instead think about making incremental transformations to the entire
input, using the existing recursion patterns that we know of. Here’s a
much more idiomatic implementation of `foobar`:
-->
<p>看起来足够直白，但是并不是最好的 Haskell 风格。问题出在：</p>
<ul>
<li>同时做了太多事；</li>
<li>过于低层。</li>
</ul>
<p>我们可以使用现有的几个递归模式，在整个输入上做增量变换，而不是考虑对每一个元素做什么。 下面是一个更为常用的 <code>foobar</code> 的实现：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">foobar&#39; ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
foobar&#39; <span class="fu">=</span> sum <span class="fu">.</span> map ((<span class="fu">+</span><span class="dv">2</span>) <span class="fu">.</span> (<span class="fu">*</span><span class="dv">7</span>)) <span class="fu">.</span> filter (<span class="fu">&gt;</span><span class="dv">3</span>)</code></pre></div>
<!--
This defines `foobar'` as a “pipeline” of three functions: first, we
throw away all elements from the list which are not greater than three;
next, we apply an arithmetic operation to every element of the remaining
list; finally, we sum the results.
-->
<p><code>foobar'</code> 被定义为三个函数串联的管道： 首先从列表中排除所有大于三的元素，然后对每个剩下的元素做算术操作，最后求和。</p>
<!--
Notice that in the above example, `map` and `filter` have been partially
applied. For example, the type of `filter` is
-->
<p>注意在上面的例子中，<code>map</code> 和 <code>filter</code> 都是被部分应用的。例如，<code>filter</code> 的类型为：</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</code></pre></div>
<!--
Applying it to `(>3)` (which has type `Integer -> Bool`) results in a
function of type `[Integer] -> [Integer]`, which is exactly the right
sort of thing to compose with another function on `[Integer]`.
-->
<p>应用在 <code>(&gt;3)</code>(其类型为 <code>Integer -&gt; Bool</code>)上，返回一个类型为 <code>[Integer] -&gt; [Integer]</code> 的函数。 恰好能和另一个在 <code>[Integer]</code> 上的函数组合。</p>
<!--
**Point-free Style**
-->
<p><strong>Point-free 风格</strong></p>
<!--
The style of coding in which we define a function without reference to
its arguments—in some sense saying what a function *is* rather than what
it *does*—is known as “point-free” style. As we can see from the above
example, it can be quite beautiful. Some people might even go so far as
to say that you should always strive to use point-free style; but taken
too far it can become extremely confusing. `lambdabot` in the `#haskell`
IRC channel has a command `@pl` for turning functions into equivalent
point-free expressions; here’s an example:
-->
<p>这种定义一个函数而不具名其参数 —— 与其在说定义函数 <em>是什么</em>，不如说在定义函数 <em>做什么</em> —— 常被称为 “point-free” 风格。 从上面的例子可以看出，这种风格有时非常优美。有些人可能会<!--渐行渐远了-->认为无论什么时候都应该使用 point-free 风格； 但是过于追求这种风格反而会造成巨大的困惑。 IRC 频道 <code>#haskell</code> 中的 <code>lambdabot</code> 有一个命令是 <code>@pl</code>，可以把函数转化为等价的 point-free 表达式；下面是一个例子：</p>
<pre><code>@pl \f g x y -&gt; f (x ++ g x) (g y)
join . ((flip . ((.) .)) .) . (. ap (++)) . (.)</code></pre>
<!--
This is clearly *not* an improvement!
-->
<p>这可 <em>一点也没有</em> 提升！</p>
<!--
Consider the following two functions:
-->
<p>再看下面两个函数：</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">mumble  <span class="fu">=</span> (<span class="ot">`foldr`</span> []) <span class="fu">.</span> ((<span class="fu">:</span>)<span class="fu">.</span>)

grumble <span class="fu">=</span> zipWith (<span class="fu">$</span>) <span class="fu">.</span> repeat</code></pre></div>
<!--
Can you figure out what these functions do? What if I told you that they
are both equivalent to the `map` function. These are great examples of
how point-free style can be taken too far. For this reason, some people
refer to it as point-less style.
-->
<p>你能明白他们在做什么吗？其实他们都等价于 <code>map</code> 函数。 这些都是 point-free 风格过犹不及的例子。所以有些人称之为 point-less（没有要点）风格。</p>
<hr />
  </body>
</html>
